<!doctype html>

<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>

  <link rel="import" href="helpers.html">
  <link rel="import" href="../all-imports.html">
</head>

<body>

  <script>
    describe('class name generator', () => {
      let grid, firstCell, initialCellClasses;

      beforeEach(() => {

        grid = document.createElement('vaadin-grid');
        grid.size = 200;
        grid.dataProvider = infiniteDataProvider;

        [0, 1].forEach(i => {
          const column = document.createElement('vaadin-grid-column');
          grid.appendChild(column);
          column.path = 'value';
          column.header = 'col' + i;
        });
        document.body.appendChild(grid);
        flushGrid(grid);

        firstCell = getContainerCell(grid.$.items, 0, 0);

        // Polyfills may add some extra classes to cells
        initialCellClasses = Array.from(firstCell.classList);
      });

      afterEach(() => {
        document.body.removeChild(grid);
      });

      const assertClassList = (cell, expectedClasses) =>
        expect(Array.from(cell.classList)).to.deep.equal(initialCellClasses.concat(expectedClasses));

      it('should add classes for cells', () => {
        grid.cellClassNameGenerator = (rowData, column) => 'foo';
        assertClassList(firstCell, ['foo']);
        assertClassList(getContainerCell(grid.$.items, 1, 1), ['foo']);
      });

      it('should add all classes separated by whitespaces', () => {
        grid.cellClassNameGenerator = (rowData, column) => 'foo bar baz';
        assertClassList(firstCell, ['foo', 'bar', 'baz']);
      });

      it('should not remove existing classes', () => {
        firstCell.classList.add('bar');
        grid.cellClassNameGenerator = (rowData, column) => 'foo';
        assertClassList(firstCell, ['bar', 'foo']);
      });

      it('should remove old generated classes', () => {
        grid.cellClassNameGenerator = (rowData, column) => 'foo';
        grid.cellClassNameGenerator = (rowData, column) => 'bar';
        assertClassList(firstCell, ['bar']);
      });

      it('should provide rowData and column as parameters', () => {
        grid.cellClassNameGenerator = (rowData, column) =>
          rowData.index + ' ' + rowData.item.value + ' ' + column.header;
        assertClassList(getContainerCell(grid.$.items, 5, 1), ['5', 'foo5', 'col1']);
        assertClassList(getContainerCell(grid.$.items, 10, 0), ['10', 'foo10', 'col0']);
      });

      it('should add classes when loading new items', function(done) {
        grid.cellClassNameGenerator = (rowData, column) => rowData.item.value;
        scrollToEnd(grid, () => {
          const rows = getRows(grid.$.items);
          const lastRow = rows[rows.length - 1];
          const cell = lastRow.firstElementChild;
          assertClassList(cell, ['foo199']);
          done();
        });
      });

      it('should not throw with falsy return value', () => {
        expect(() => grid.cellClassNameGenerator = (rowData, column) => {}).not.to.throw(Error);
      });

      it('should clear generated classes with falsy return value', () => {
        grid.cellClassNameGenerator = (rowData, column) => 'foo';
        grid.cellClassNameGenerator = (rowData, column) => {};
        assertClassList(firstCell, []);
      });

      ['generateClassNames', 'clearCache', 'render'].forEach(funcName => {
        it(`should update classes on ${funcName}`, () => {
          let condition = false;
          grid.cellClassNameGenerator = (rowData, column) => condition && 'foo';
          condition = true;
          assertClassList(firstCell, []);
          grid[funcName]();
          assertClassList(firstCell, ['foo']);
        });
      });
    });
  </script>

</body>
</html>
