<!doctype html>

<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../../test-fixture/test-fixture.html">

  <link rel="import" href="helpers.html">
  <link rel="import" href="../all-imports.html">
</head>

<body>

<test-fixture id="default">
  <template>
    <vaadin-grid>
      <vaadin-grid-column path="first" header="First name"></vaadin-grid-column>
      <vaadin-grid-column path="last" header="Last name"></vaadin-grid-column>
    </vaadin-grid>
  </template>
</test-fixture>

<script>
describe('drag and drop', () => {
  let grid;

  const getDraggable = (grid, rowIndex = 0) => {
    const row = Array.from(grid.$.items.children).filter(row => row.index === rowIndex)[0];
    const cellContent = row.querySelector('slot').assignedNodes()[0];
    return [row, cellContent].filter(node => node.getAttribute('draggable') === 'true')[0];
  };

  const fireDragStart = (draggable = getDraggable(grid)) => {
    const event = new Event('dragstart', {
      bubbles: true,
      cancelable: true,
      composed: true
    });
    event.dataTransfer = {
      setDragImage: () => {},
      setData: (type, data) => {
        event.__dataType = type;
        event.__data = data;
      }
    };
    draggable.dispatchEvent(event);
    return event;
  };

  const fireDragEnd = (draggable = getDraggable(grid)) => {
    const event = new Event('dragend', {
      bubbles: true,
      cancelable: true,
      composed: true
    });
    draggable.dispatchEvent(event);
    return event;
  };

  const fireDragLeave = (draggable = getDraggable(grid)) => {
    const event = new Event('dragleave', {
      bubbles: true,
      cancelable: true,
      composed: true
    });
    draggable.dispatchEvent(event);
  };

  const fireDrop = (draggable = getDraggable(grid)) => {
    const event = new Event('drop', {
      bubbles: true,
      cancelable: true,
      composed: true
    });
    event.dataTransfer = {
      getData: () => 'foo',
      types: ['text']
    };
    draggable.dispatchEvent(event);
    return event;
  };

  const fireDragOver = (row, location) => {
    const event = new Event('dragover', {
      bubbles: true,
      cancelable: true,
      composed: true
    });
    if (row) {
      const rect = row.getBoundingClientRect();
      if (location === 'on-top') {
        event.clientY = rect.top + rect.height / 2;
      } else if (location === 'above') {
        event.clientY = rect.top;
      } else if (location === 'below') {
        event.clientY = rect.bottom;
      } else if (location === 'under') {
        event.clientY = rect.bottom + rect.height / 2;
      }
      row.dispatchEvent(event);
    } else {
      getDraggable(grid).dispatchEvent(event);
    }
    return event;
  };

  beforeEach(done => {
    grid = fixture('default');
    grid.hidden = true;
    requestAnimationFrame(() => {
      // Wait for the appear animation to finish
      listenOnce(grid, 'animationend', () => {
        grid.items = [
          {first: 'foo', last: 'bar'},
          {first: 'baz', last: 'qux'}
        ];
        flushGrid(grid);
        flush(() => done());
      });
      requestAnimationFrame(() => grid.hidden = false);
    });
  });

  it('should not be draggable by default', () => {
    expect(getDraggable(grid)).not.to.be.ok;
  });

  describe('draggable', () => {

    beforeEach(() => {
      grid.rowsDraggable = true;
      flushGrid(grid);
    });

    it('should be draggable', () => {
      expect(getDraggable(grid)).to.be.ok;
    });

    it('should not be draggable', () => {
      grid.rowsDraggable = false;
      expect(getDraggable(grid)).not.to.be.ok;
    });

    describe('dragstart', () => {

      let dragStartSpy;

      beforeEach(() => {
        grid.rowsDraggable = true;
        dragStartSpy = sinon.spy();
        grid.addEventListener('grid-dragstart', dragStartSpy);
      });

      it('should stop the native event', () => {
        const spy = sinon.spy();
        grid.addEventListener('dragstart', spy);
        fireDragStart();
        expect(spy.called).to.be.false;
      });

      it('should not stop the native event', () => {
        const spy = sinon.spy();
        grid.addEventListener('dragstart', spy);
        fireDragStart(getFirstCell(grid));
        expect(spy.called).to.be.true;
      });

      it('should not stop the native event when not draggable', () => {
        const spy = sinon.spy();
        grid.addEventListener('dragstart', spy);
        grid.rowsDraggable = false;
        const event = new Event('dragstart', {
          bubbles: true,
          cancelable: true,
          composed: true
        });
        getBodyCellContent(grid, 0, 0).dispatchEvent(event);
        expect(spy.called).to.be.true;
      });

      it('should add dragging state attribute', () => {
        fireDragStart();
        expect(grid.hasAttribute('dragging-rows')).to.be.true;
      });

      it('should add dragged row count state attribute for drag image', done => {
        grid.selectedItems = grid.items;
        fireDragStart();
        const row = getRows(grid.$.items)[0];
        expect(row.getAttribute('dragstart')).to.equal('2');

        requestAnimationFrame(() => {
          expect(row.hasAttribute('dragstart')).to.be.false;
          done();
        });
      });

      it('should not add count to dragstart attribute on single row drag', () => {
        fireDragStart();
        const row = getRows(grid.$.items)[0];
        expect(row.getAttribute('dragstart')).to.equal('');
      });

      it('should use top on Safari for drag image', done => {
        if (grid._safari) {
          const row = getRows(grid.$.items)[0];
          const originalTransform = row.style.transform;
          fireDragStart();

          expect(row.style.top).to.be.ok;
          expect(row.style.transform).to.equal('none');

          requestAnimationFrame(() => {
            expect(row.style.top).not.to.be.ok;
            expect(row.style.transform).to.equal(originalTransform);
            done();
          });
        } else {
          // The test only concerns Safari
          done();
        }
      });

      it('should dispatch a grid specific event', () => {
        fireDragStart();
        expect(dragStartSpy.calledOnce).to.be.true;
      });

      it('should have the original event', () => {
        const originalEvent = fireDragStart();
        const event = dragStartSpy.getCall(0).args[0];
        expect(event.originalEvent).to.equal(originalEvent);
      });

      it('should reference the dragged item', () => {
        fireDragStart();
        const event = dragStartSpy.getCall(0).args[0];
        expect(event.detail.items).to.eql([grid.items[0]]);
      });

      it('should reference the dragged item only', () => {
        grid.selectItem(grid.items[1]);
        fireDragStart();
        const event = dragStartSpy.getCall(0).args[0];
        expect(event.detail.items).to.eql([grid.items[0]]);
      });

      it('should reference all the selected items', () => {
        grid.selectedItems = grid.items;
        fireDragStart();
        const event = dragStartSpy.getCall(0).args[0];
        expect(event.detail.items).to.eql(grid.items);
      });

      it('should auto generate data transfer text data', () => {
        grid.selectedItems = grid.items;
        const e = fireDragStart();
        expect(e.__data).to.eql('foo\tbar\nbaz\tqux');
      });

      it('should auto generate data transfer text data in order', () => {
        grid.selectedItems = grid.items;
        const columns = grid.querySelectorAll('vaadin-grid-column');
        grid._swapColumnOrders(columns[0], columns[1]);
        const e = fireDragStart();
        expect(e.__data).to.eql('bar\tfoo\nqux\tbaz');
      });

      it('should generate custom data transfer text data', () => {
        grid.selectedItems = grid.items;
        grid.formatDragData = items => {
          return [{
            type: 'text/plain',
            data: items.map(item => item.last).join(',')
          }];
        };
        const e = fireDragStart();
        expect(e.__data).to.eql('bar,qux');
        expect(e.__dataType).to.eql('text/plain');
      });

    });

    describe('dragend', () => {

      let dragEndSpy;

      beforeEach(() => {
        dragEndSpy = sinon.spy();
        grid.addEventListener('grid-dragend', dragEndSpy);
      });

      it('should stop the native event', () => {
        const spy = sinon.spy();
        grid.addEventListener('dragend', spy);
        fireDragEnd();
        expect(spy.called).to.be.false;
      });

      it('should remove dragging state attribute', () => {
        fireDragStart();
        fireDragEnd();
        expect(grid.hasAttribute('dragging-rows')).to.be.false;
      });

      it('should dispatch a grid specific event', () => {
        fireDragEnd();
        expect(dragEndSpy.calledOnce).to.be.true;
      });

      it('should have the original event', () => {
        const originalEvent = fireDragEnd();
        const event = dragEndSpy.getCall(0).args[0];
        expect(event.originalEvent).to.equal(originalEvent);
      });

    });

    describe('dragover', () => {

      it('should not stop the native event', () => {
        const spy = sinon.spy();
        grid.addEventListener('dragover', spy);
        fireDragOver();
        expect(spy.called).to.be.true;
      });

      it('should stop the native event', () => {
        grid.dropMode = 'between';

        const spy = sinon.spy();
        grid.addEventListener('dragover', spy);
        fireDragOver();
        expect(spy.called).to.be.false;
      });

      it('should not cancel the native event', () => {
        const e = fireDragOver();
        expect(e.defaultPrevented).to.be.false;
      });

      it('should cancel the native event', () => {
        grid.dropMode = 'between';

        const e = fireDragOver();
        expect(e.defaultPrevented).to.be.true;
      });

      it('should set dragover attribute to grid on on-grid dropmode', () => {
        grid.dropMode = 'on-grid';
        fireDragOver();
        expect(grid.hasAttribute('dragover')).to.be.true;
      });

      it('should not set dragover attribute to the grid', () => {
        grid.dropMode = 'on-top';
        const row = grid.$.items.children[0];
        fireDragOver(row, 'above');
        expect(grid.hasAttribute('dragover')).to.be.false;
      });

      it('should set dragover=on-top attribute to the row', () => {
        grid.dropMode = 'on-top';
        const row = grid.$.items.children[0];
        fireDragOver(row, 'above');
        expect(row.getAttribute('dragover')).to.equal('on-top');
      });

      it('should set dragover=on-top attribute to the row 2', () => {
        grid.dropMode = 'on-top-or-between';
        const row = grid.$.items.children[0];
        fireDragOver(row, 'on-top');
        expect(row.getAttribute('dragover')).to.equal('on-top');
      });

      it('should set dragover=above attribute to the row', () => {
        grid.dropMode = 'between';
        const row = grid.$.items.children[0];
        fireDragOver(row, 'above');
        expect(row.getAttribute('dragover')).to.equal('above');
      });

      it('should set dragover=below attribute to the row', () => {
        grid.dropMode = 'between';
        const row = grid.$.items.children[0];
        fireDragOver(row, 'below');
        expect(row.getAttribute('dragover')).to.equal('below');
      });

      it('should set dragover=above attribute to the row 2', () => {
        grid.dropMode = 'on-top-or-between';
        const row = grid.$.items.children[0];
        fireDragOver(row, 'above');
        expect(row.getAttribute('dragover')).to.equal('above');
      });

      it('should set dragover=below attribute to the row 2', () => {
        grid.dropMode = 'on-top-or-between';
        const row = grid.$.items.children[0];
        fireDragOver(row, 'below');
        expect(row.getAttribute('dragover')).to.equal('below');
      });

      it('should set dragover=below attribute to the last row', () => {
        grid.dropMode = 'on-top-or-between';
        const row = grid.$.items.children[1];
        fireDragOver(row, 'under');
        expect(row.getAttribute('dragover')).to.equal('below');
      });

    });

    describe('dragleave', () => {

      it('should stop the native event', () => {
        const spy = sinon.spy();
        grid.addEventListener('dragleave', spy);
        fireDragLeave();
        expect(spy.called).to.be.false;
      });

      it('should clear the grid drag styles', () => {
        grid.dropMode = 'on-grid';
        fireDragOver();
        expect(grid.hasAttribute('dragover')).to.be.true;
        fireDragLeave();
        expect(grid.hasAttribute('dragover')).to.be.false;
      });

      it('should clear the row drag styles', () => {
        grid.dropMode = 'on-top';
        fireDragOver();
        const row = grid.$.items.children[0];
        expect(row.hasAttribute('dragover')).to.be.true;
        fireDragLeave();
        expect(row.hasAttribute('dragover')).to.be.false;
      });

    });

    describe('drop', () => {
      let dropSpy;

      beforeEach(() => {
        grid.dropMode = 'on-top';
        dropSpy = sinon.spy();
        grid.addEventListener('grid-drop', dropSpy);
      });

      it('should stop the native event', () => {
        const spy = sinon.spy();
        grid.addEventListener('drop', spy);
        fireDrop();
        expect(spy.called).to.be.false;
      });

      it('should cancel the native event', () => {
        const event = fireDrop();
        expect(event.defaultPrevented).to.be.true;
      });

      it('should clear the grid drag styles', () => {
        grid.dropMode = 'on-grid';
        fireDragOver();
        expect(grid.hasAttribute('dragover')).to.be.true;
        fireDrop();
        expect(grid.hasAttribute('dragover')).to.be.false;
      });

      it('should clear the row drag styles', () => {
        grid.dropMode = 'on-top';
        fireDragOver();
        const row = grid.$.items.children[0];
        expect(row.hasAttribute('dragover')).to.be.true;
        fireDrop();
        expect(row.hasAttribute('dragover')).to.be.false;
      });

      it('should dispatch a grid specific event', () => {
        fireDrop();
        expect(dropSpy.calledOnce).to.be.true;
      });

      it('should bubble and be cancelable', () => {
        fireDrop();
        const event = dropSpy.getCall(0).args[0];
        expect(event.bubbles).to.be.true;
        expect(event.cancelable).to.be.true;
      });

      it('should reference the drop target item', () => {
        grid.dropMode = 'on-top';
        fireDragOver();
        fireDrop();
        const event = dropSpy.getCall(0).args[0];
        expect(event.detail.item).to.eql(grid.items[0]);
      });

      it('should have the drop location', () => {
        grid.dropMode = 'between';
        const row = grid.$.items.children[0];
        fireDragOver(row, 'above');
        fireDrop();
        const event = dropSpy.getCall(0).args[0];
        expect(event.detail.dropLocation).to.eql('above');
      });

      it('should have the payload data', () => {
        grid.dropMode = 'on-top';
        fireDragOver();
        fireDrop();
        const event = dropSpy.getCall(0).args[0];
        expect(event.detail.dragData).to.eql([{type: 'text', data: 'foo'}]);
      });

      it('should have the original event', () => {
        const originalEvent = fireDrop();
        const event = dropSpy.getCall(0).args[0];
        expect(event.originalEvent).to.equal(originalEvent);
      });
    });

  });

  describe('filtering row drag', () => {

    beforeEach(() => {
      grid.dragFilter = ({item}) => item.first !== 'foo';
      grid.rowsDraggable = true;
    });

    it('should not disable row drag', () => {
      expect(getDraggable(grid, 1)).to.be.ok;
      expect(grid.$.items.children[1].hasAttribute('drag-disabled')).to.be.false;
    });

    it('should disable row drag', () => {
      expect(getDraggable(grid, 0)).not.to.be.ok;
      expect(grid.$.items.children[0].hasAttribute('drag-disabled')).to.be.true;
    });

    it('should re-run the row drag filter', () => {
      grid.items[1].first = 'foo';
      grid.filterDragAndDrop();
      expect(getDraggable(grid, 1)).not.to.be.ok;
    });

    it('should re-enable row drag', () => {
      grid.dragFilter = ({item}) => item.first === 'foo';
      expect(getDraggable(grid, 0)).to.be.ok;
    });

    it('should re-enable row drag 2', () => {
      grid.dragFilter = undefined;
      expect(getDraggable(grid, 0)).to.be.ok;
    });

  });

  describe('filtering row drop', () => {

    beforeEach(() => {
      grid.dropFilter = ({item}) => item.first !== 'foo';
      grid.dropMode = 'on-top';
    });

    it('should not disable drop on row', () => {
      const row = grid.$.items.children[1];
      fireDragOver(row, 'above');
      expect(row.hasAttribute('dragover')).to.be.true;
      expect(row.hasAttribute('drop-disabled')).to.be.false;
    });

    it('should disable drop on row', () => {
      const row = grid.$.items.children[0];
      fireDragOver(row, 'above');
      expect(row.hasAttribute('dragover')).to.be.false;
      expect(row.hasAttribute('drop-disabled')).to.be.true;
    });

    it('should re-enable drop on row', () => {
      grid.dropFilter = ({item}) => item.first === 'foo';
      const row = grid.$.items.children[0];
      fireDragOver(row, 'above');
      expect(row.hasAttribute('dragover')).to.be.true;
      expect(row.hasAttribute('drop-disabled')).to.be.false;
    });

    it('should re-enable drop on row 2', () => {
      grid.dropFilter = undefined;
      const row = grid.$.items.children[0];
      fireDragOver(row, 'above');
      expect(row.hasAttribute('dragover')).to.be.true;
      expect(row.hasAttribute('drop-disabled')).to.be.false;
    });

    it('should emit a grid-drop event for non drop disabled row', () => {
      const spy = sinon.spy();
      grid.addEventListener('grid-drop', spy);
      fireDrop(grid.$.items.children[1]);
      expect(spy.called).to.be.true;
    });

    it('should cancel dragover on a row with drop enabled', () => {
      const row = grid.$.items.children[1];
      const e = fireDragOver(row, 'above');
      expect(e.defaultPrevented).to.be.true;
    });

    it('should not cancel dragover on a row with drop disabled', () => {
      const row = grid.$.items.children[0];
      const e = fireDragOver(row, 'above');
      expect(e.defaultPrevented).to.be.false;
    });

  });
});


</script>

</body>

</html>
