<!doctype html>

<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>

  <link rel="import" href="helpers.html">
  <link rel="import" href="../vaadin-grid.html">
</head>

<body>

  <test-fixture id="default">
    <template>
      <vaadin-grid style="width: 50px; height: 400px;" size="1000">
        <vaadin-grid-column width="200px" frozen>
          <template>[[index]]</template>
        </vaadin-grid-column>
      </vaadin-grid>
    </template>
  </test-fixture>

  <script>
    describe('outer scroller', function() {
      var grid;
      var scroller;
      var outerScroller;
      var target;
      var tableRect;

      beforeEach(function(done) {
        grid = fixture('default');
        grid.dataSource = infiniteDataSource;
        scroller = grid.$.scroller;
        outerScroller = scroller.$.outerscroller;
        outerScroller.hidden = false;
        target = outerScroller.scrollTarget;
        tableRect = scroller.$.table.getBoundingClientRect();
        Polymer.Base.async(done, 1);
      });

      it('should invoke onScroll synchronously', function() {
        var spy = sinon.spy(scroller, '_translateStationaryElements');
        outerscroller._syncScrollTarget();
        expect(spy.called).to.be.true;
      });

      it('should invoke frozen element translate handler', function(done) {
        var spy = sinon.spy(scroller, '_translateStationaryElements');
        outerScroller.scrollLeft = 1;
        setTimeout(function () {
          expect(spy.called).to.be.true;
          done();
        }, 200);
      });

      it('should have the same size as the scroller', function() {
        var outerRect = outerScroller.getBoundingClientRect();
        expect(outerRect.left).to.eql(tableRect.left);
        expect(outerRect.right).to.eql(tableRect.right);
        expect(outerRect.top).to.eql(tableRect.top);
        expect(outerRect.bottom).to.eql(tableRect.bottom);
      });

      it('should have the same scrollHeight/scrollWidth as the target', function() {
        expect(outerScroller.scrollHeight).to.eql(target.scrollHeight);
        expect(outerScroller.scrollWidth).to.eql(target.scrollWidth);
      });

      describe('syncing with scroll target', function() {

        it('should scroll the target', function(done) {
          outerScroller.addEventListener('scroll', function() {
            expect(target.scrollLeft).to.equal(1);
            done();
          });
          outerScroller.scrollLeft = 1;
        });

        it('should scroll the outer scroller', function(done) {
          target.addEventListener('scroll', function() {
            expect(outerScroller.scrollLeft).to.equal(1);
            done();
          });
          target.scrollLeft = 1;
        });

      });

      describe('passtrough pointer events', function() {

        function move(x, y) {
          makeMouseEvent('mousemove', {x: x, y: y}, scroller);
        }

        var HAS_NEW_MOUSE = (function() {
          var has = false;
          try {
            has = Boolean(new MouseEvent('x'));
          } catch (_) {}
          return has;
        })();

        function makeMouseEvent(type, xy, node) {
          var props = {
            bubbles: true,
            cancelable: true,
            clientX: xy.x,
            clientY: xy.y,
            // Make this a primary input.
            buttons: 1 // http://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
          };
          var e;
          if (HAS_NEW_MOUSE) {
            e = new MouseEvent(type, props);
          } else {
            e = document.createEvent('MouseEvent');
            e.initMouseEvent(
              type, props.bubbles, props.cancelable,
              null, /* view */
              null, /* detail */
              0,    /* screenX */
              0,    /* screenY */
              props.clientX, props.clientY,
              false, /*ctrlKey */
              false, /*altKey */
              false, /*shiftKey */
              false, /*metaKey */
              0,     /*button */
              null   /*relatedTarget*/);
          }
          node.dispatchEvent(e);
        }

        function outerScrollerInUse() {
          return window.getComputedStyle(outerScroller).pointerEvents !== 'none';
        }

        it('should passtrough pointer events', function(done) {
          scroller.addEventListener('mousemove', function() {
            expect(outerScrollerInUse()).to.be.false;
            done();
          });

          move(1, 1);
        });

        it('should not passtrough iff scrollbars exist (vertical scrollbar hover)', function(done) {
          scroller.addEventListener('mousemove', function() {
            expect(outerScrollerInUse()).to.be[getScrollbarWidth() > 0 ? 'true' : 'false'];
            done();
          });
          move(tableRect.width, 1);
        });

        it('should not passtrough iff scrollbars exist (horizontal scrollbar hover)', function(done) {
          scroller.addEventListener('mousemove', function() {
            expect(outerScrollerInUse()).to.be[getScrollbarWidth() > 0 ? 'true' : 'false'];
            done();
          });
          move(1, tableRect.height);
        });

      });

    });
  </script>

</body>

</html>
