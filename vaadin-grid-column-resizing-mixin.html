<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/lib/mixins/gesture-event-listeners.html">

<dom-module id="vaadin-grid-column-resizing-styles">
  <template>
    <style>
      [part~="resize-handle"] {
        position: absolute;
        top: 0;
        right: 0;
        height: 100%;
        cursor: col-resize;
        z-index: 1;
      }

      [part~="resize-handle"]::before {
        position: absolute;
        content: "";
        height: 100%;
        width: 35px;
        transform: translateX(-50%);
      }

      [lastcolumn] [part~="resize-handle"]::before,
      [last-frozen] [part~="resize-handle"]::before {
        width: 18px;
        transform: translateX(-100%);
      }

      #scroller[column-resizing] {
        -ms-user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        user-select: none;
      }
    </style>
  </template>
</dom-module>

<script>
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.Grid = window.Vaadin.Grid || {};

  /**
   * @polymerMixin
   */
  Vaadin.Grid.ColumnResizingMixin = superClass => class ColumnResizingMixin extends Polymer.GestureEventListeners(superClass) {

    ready() {
      super.ready();
      const el = this.$.scroller;
      Polymer.Gestures.addListener(el, 'track', this._onHeaderTrack.bind(this));

      // Allow scrolling in headers if not resizing.
      el.addEventListener('touchmove', e => el.hasAttribute('column-resizing') && e.preventDefault());

      // Disable contextmenu if header has reordering enabled or when on resize separator
      el.addEventListener('contextmenu',
        e => (this.columnReorderingAllowed || e.currentTarget.getAttribute('part') != 'resize-handle') && e.preventDefault());
    }

    _onHeaderTrack(e) {
      const handle = e.target;
      if (handle.getAttribute('part') === 'resize-handle') {
        const cell = handle.parentElement;
        let column = cell._column;

        this.$.scroller.setAttribute('column-resizing', '');

        // Get the target column to resize
        if (column.localName === 'vaadin-grid-column-group') {
          column = Array.prototype.slice.call(column._childColumns, 0)
          .sort(function(a, b) {
            return a._order - b._order;
          })
          .filter(function(column) {
            return !column.hidden;
          }).pop();
        }

        const columnRowCells = Array.from(this.$.header.querySelectorAll('[part~="row"]:last-child [part~="cell"]'));
        var targetCell = columnRowCells.filter(cell => cell._column === column)[0];
        // Resize the target column
        if (targetCell.offsetWidth) {
          var style = window.getComputedStyle(targetCell);
          var minWidth = 10 + parseInt(style.paddingLeft) + parseInt(style.paddingRight) + parseInt(style.borderLeft) + parseInt(style.borderRight) + parseInt(style.marginLeft) + parseInt(style.marginRight);
          column.width = Math.max(minWidth, targetCell.offsetWidth + e.detail.x - targetCell.getBoundingClientRect().right) + 'px';
          column.flexGrow = 0;
        }
        // Fix width and flex-grow for all preceding columns
        columnRowCells
          .sort(
            function(a, b) {
              return a._column._order - b._column._order;
            })
          .forEach(function(cell, index, array) {
            if (index < array.indexOf(targetCell)) {
              cell._column.width = cell.offsetWidth + 'px';
              cell._column.flexGrow = 0;
            }
          });

        if (e.detail.state === 'end') {
          this.$.scroller.removeAttribute('column-resizing');
        }
      }

      // Notify resize
      this._resizeHandler();
    }

  };
</script>
