<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.Grid = window.Vaadin.Grid || {};

  // TODO: Scope
  class CacheItem {

    constructor() {
      this.expandedItems = {};
      this.map = {};
      this.size = -1; // Size must include all expanded items sizes
    }

    getItemForIndex(index) {
      const {cache, scaledIndex} = this.getCacheAndIndex(index);
      return cache.map[scaledIndex];
    }

    setItemForScaledIndex(scaledIndex, item) {
      this.map[scaledIndex] = item;
    }

    getEffectiveSize() {
      return this.collapsed ? 0 : this.size;
    }

    updateSize() {
      this.size = this.ownSize + Object.keys(this.expandedItems).reduce((prev, curr) => {
        return prev + this.expandedItems[curr].getEffectiveSize();
      }, 0);

      if (this.parentCache) {
        this.parentCache.updateSize();
      }
    }

    expandIndex(index) {
      const {cache, scaledIndex} = this.getCacheAndIndex(index);
      cache.expandedItems[scaledIndex] = cache.expandedItems[scaledIndex] || new CacheItem();
      cache.expandedItems[scaledIndex].collapsed = false;
      cache.expandedItems[scaledIndex].parentCache = cache;
      cache.expandedItems[scaledIndex].parentItem = cache.map[scaledIndex];
      cache.updateSize();
    }

    collapseIndex(index) {
      const {cache, scaledIndex} = this.getCacheAndIndex(index);
      cache.expandedItems[scaledIndex].collapsed = true;
      cache.updateSize();
    }

    getCacheAndIndex(index) {
      let thisLevelIndex = index;
      const keys = Object.keys(this.expandedItems)
        .map(Number) // JS gotcha: Object.keys() are strings
        .sort((b, a) => b - a) // JS gotcha: default sort() comparison is string-based
        .filter(expandedIndex => {
          return !this.expandedItems[expandedIndex].collapsed;
        });
      for (var i = 0; i < keys.length; i++) {
        const expandedIndex = keys[i];
        const subCache = this.expandedItems[expandedIndex];
        if (thisLevelIndex <= expandedIndex) {
          return {cache: this, scaledIndex: thisLevelIndex};
        } else if (subCache.size === -1) {
          return {cache: subCache, scaledIndex: thisLevelIndex - expandedIndex - 1};
        } else if (thisLevelIndex <= expandedIndex + subCache.getEffectiveSize()) {
          return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);
        }
        thisLevelIndex -= subCache.getEffectiveSize();
      }
      return {cache: this, scaledIndex: thisLevelIndex};
    }

  }


  /**
   * @polymerMixin
   */
  Vaadin.Grid.DataProviderMixin = superClass => class DataProviderMixin extends superClass {

    static get properties() {
      return {

        /**
         * Number of items fetched at a time from the dataprovider.
         */
        pageSize: {
          type: Number,
          value: 50,
          observer: '_pageSizeChanged'
        },

        /**
         * Function that provides items lazily. Receives arguments `params`, `callback`
         *
         * `params.page` Requested page index
         *
         * `params.pageSize` Current page size
         *
         * `params.filters` Currently applied filters
         *
         * `params.sortOrders` Currently applied sorting orders
         *
         */
        dataProvider: {
          type: Object,
          notify: true,
          observer: '_dataProviderChanged'
        },

        /**
         * `true` while data is being requested from the data provider.
         */
        _loading: {
          type: Boolean,
          observer: '_loadingChanged'
        },

        _cache: {
          type: Object,
          value: function() {
            const cache = new CacheItem();
            cache.size = 100000000; // TODO:
            return cache;
          }
        },

        _pendingRequests: {
          type: Object,
          value: function() {
            return {};
          }
        },
      };
    }

    static get observers() {
      return [
        '_updateCacheSize(size)'
      ];
    }

    _updateCacheSize(size) {
      this._cache.ownSize = size;
      this._cache.updateSize();
      this._fullSize = this._cache.size;
    }

    _loadingChanged(loading) {
      this._toggleAttribute('loading', loading, this);
    }

    _updateRowItem(item, el) {
      el.children.forEach(cell => {
        cell._instance && (cell._instance.item = item);
      });
    }

    _getItem(index, el) {

      el.index = index;
      const item = this._cache.getItemForIndex(index);
      if (item) {
        this._updateItem(el, item);
      } else {
        const {cache, scaledIndex} = this._cache.getCacheAndIndex(index);
        const pageForIndex = this._getPageForIndex(scaledIndex);
        this._loadPage(pageForIndex, cache);
      }

    }

    // _cachedPagesForPhysicalItems() {
    //   return this._pagesForPhysicalItems().filter(page => this._cache !== undefined && this._cache[page] !== undefined);
    // }
    //
    // _uncachedPagesForPhysicalItems() {
    //   return this._pagesForPhysicalItems().filter(page => this._cache !== undefined && this._cache[page] === undefined);
    // }
    //
    // _eagerlyLoadPages() {
    //   const pages = this._cachedPagesForPhysicalItems().slice(0);
    //
    //   if (pages.length > 0) {
    //     pages.sort((a, b) => a > b);
    //
    //     const prev = Math.max(0, pages[0] - 1);
    //     const next = Math.min(pages[pages.length - 1] + 1, Math.max(0, Math.floor(this.size / this.pageSize) - 1));
    //
    //     this._loadPage(prev);
    //     this._loadPage(next);
    //   }
    // }

    _pagesForPhysicalItems() {
      // TODO: potentially heavy operation to run first visible index,
      // reconsider if performance issues occur on data binding / scrolling.
      // TODO: _vidxOffset shouldn't be read from here.
      const firstVisiblePage = this._getPageForIndex(this._firstVisibleIndex + this._vidxOffset);

      return [firstVisiblePage].concat(
        this._physicalItems
          .filter(row => row.index)
          .map(row => this._getPageForIndex(row.index))
        ).reduce((prev, curr) => {
          if (prev.indexOf(curr) === -1) {
            prev.push(curr);
          }

          return prev;
        }, []);
    }

    expandIndex(index) {
      this._cache.expandIndex(index);
      this._fullSize = this._cache.size;
      this._assignModels();
    }

    collapseIndex(index) {
      this._cache.collapseIndex(index);
      this._fullSize = this._cache.size;
      this._assignModels();
    }

    _hierarchyExpandedInstanceChangedCallback(inst, value) {
      if (value) {
        this.expandIndex(inst.index);
      } else {
        this.collapseIndex(inst.index);
      }
    }

    isIndexExpanded(index) {
      const {cache, scaledIndex} = this._cache.getCacheAndIndex(index);
      const subCache = cache.expandedItems[scaledIndex];
      return Boolean(subCache && !subCache.collapsed);
    }

    _getIndexHierarchyLevel(index) {
      let {cache} = this._cache.getCacheAndIndex(index);
      let level = 0;
      while (cache.parentCache) {
        cache = cache.parentCache;
        level++;
      }
      return level;
    }

    _canPopulate() {
      return true;
    }

    _loadPage(page, cache) {
      // make sure same page isn't requested multiple times.
      if (!this._pendingRequests[page] && this.dataProvider) {
        this._pendingRequests[page] = true;
        const params = {
          page,
          pageSize: this.pageSize,
          sortOrders: this._mapSorters(),
          filters: this._mapFilters(),
          parentItem: cache.parentItem
        };

        this.dataProvider(params, (items, size) => {
          if (size !== undefined) {
            cache.ownSize = size;
          }
          cache.updateSize();
          items.forEach((item, itemsIndex) => {
            cache.setItemForScaledIndex(page * this.pageSize + itemsIndex, item);
          });
          this._fullSize = this._cache.size;

          Array.from(this.$.items.children).forEach(row => {
            const cachedItem = this._cache.getItemForIndex(row.index);
            if (items.indexOf(cachedItem) > -1) {
              this._updateItem(row, cachedItem);
            }
          });

          this._hasData = true;
          this._increasePoolIfNeeded();

          delete this._pendingRequests[page];

          this._loading = this._pendingRequests.length > 0;
        });
      }
    }

    _getPageForIndex(index) {
      return Math.floor(index / this.pageSize);
    }

    /**
     * Clears the cached pages and reloads data from dataprovider when needed.
     */
    clearCache() {
      this._cache = new CacheItem();
      this._cache.ownSize = this.size;
      this._pendingRequests = {};
      this._hasData = false;
      this._loading = true;
      this._assignModels();
    }

    _flushItemsDebouncer() {
      if (this._debouncerLoad) {
        this._debouncerLoad.flush();
      }
    }

    _pageSizeChanged(pageSize, oldPageSize) {
      if (oldPageSize !== undefined && pageSize !== oldPageSize) {
        this.clearCache();
      }
    }

    _checkSize() {
      if (this.size === undefined) {
        console.warn('The <vaadin-grid> needs a value for "size" property in order to display rows.');
      }
    }

    _dataProviderChanged(dataProvider, oldDataProvider) {
      if (oldDataProvider !== undefined) {
        this.clearCache();
      }

      if (dataProvider && this.items && this.items.length) {
        // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>
        this._scrollToIndex(this._firstVisibleIndex);
      }

      if (!this._hasData) {
        // load data before adding rows to make sure they have content when
        // rendered for the first time.
        this._loading = true;
        this._loadPage(0, this._cache, () => {
          const hadData = this._hasData;
          this._hasData = true;
          if (!hadData) {
            this.notifyResize();
          }
        });
      }

      this._debouncerCheckSize = Polymer.Debouncer.debounce(
        this._debouncerCheckSize,
        Polymer.Async.timeOut.after(2000),
        this._checkSize.bind(this));

      this._scrollHandler();
      //
      // if (dataProvider && this.items && this.items.length) {
      //   // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>
      //   this._scrollToIndex(this._firstVisibleIndex);
      // }
    }

  };
</script>
