<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="vaadin-grid-scroller.html">
<link rel="import" href="vaadin-grid-dynamic-columns-mixin.html">
<link rel="import" href="vaadin-grid-data-provider-mixin.html">
<link rel="import" href="vaadin-grid-array-data-provider-mixin.html">
<link rel="import" href="vaadin-grid-cell-click-mixin.html">
<link rel="import" href="vaadin-grid-active-item-mixin.html">
<link rel="import" href="vaadin-grid-scroll-mixin.html">
<link rel="import" href="vaadin-grid-selection-mixin.html">
<link rel="import" href="vaadin-grid-sort-mixin.html">
<link rel="import" href="vaadin-grid-row-details-mixin.html">
<link rel="import" href="vaadin-grid-keyboard-navigation-mixin.html">
<link rel="import" href="vaadin-grid-filter-mixin.html">
<link rel="import" href="vaadin-grid-column-reordering-mixin.html">
<link rel="import" href="vaadin-grid-column-resizing-mixin.html">
<link rel="import" href="vaadin-grid-column.html">
<link rel="import" href="vaadin-grid-outer-scroller.html">
<link rel="import" href="vaadin-grid-styles.html">

<dom-module id="vaadin-grid">
  <template>
    <style include="vaadin-grid-styles"></style>

    <div id="scroller" no-scrollbars$="[[!_scrollbarWidth]]" safari$="[[_safari]]" ios$="[[_ios]]" loading$=[[_loading]]>
      <table id="table" role="application grid">
        <caption>
          <!-- TODO: Implement -->
          <div id="fixedsizer"></div>
        </caption>
        <thead id="header" role="rowgroup"></thead>
        <tbody id="items" role="rowgroup"></tbody>
        <tfoot id="footer" role="rowgroup"></tfoot>
      </table>

      <div id="reorderghost"></div>
      <vaadin-grid-outer-scroller id="outerscroller"
          scroll-target="[[scrollTarget]]"
          scroll-handler="[[_this]]">
        <div id="outersizer" part='row' style$="top: [[_estScrollHeight]]px"></div>
      </vaadin-grid-outer-scroller>
    </div>

    <!-- The template needs at least one slot or else shady doesn't distribute -->
    <slot name="nodistribute"></slot>

    <div id="focusexit" tabindex="0"></div>
  </template>
</dom-module>

<script>
  if (!Polymer.Element) {
    throw new Error(`Unexpected Polymer version ${Polymer.version} is used, expected v2.0.0 or later.`);
  }

  {
    /**
     * ### Styling
     *
     * The following shadow DOM parts are exposed for styling:
     *
     * Part name | Description
     * ----------------|----------------
     * `row` | Row in the internal table
     * `cell` | Cell in the internal table
     * `header-cell` | Header cell in the internal table
     * `body-cell` | Body cell in the internal table
     * `footer-cell` | Footer cell in the internal table
     * `details-cell` | Row details cell in the internal table
     * `resize-handle` | Handle for resizing the columns
     *
     * @memberof Vaadin
     * @mixes Vaadin.ThemableMixin
     * @mixes Vaadin.Grid.DataProviderMixin
     * @mixes Vaadin.Grid.ArrayDataProviderMixin
     * @mixes Vaadin.Grid.DynamicColumnsMixin
     * @mixes Vaadin.Grid.CellClickMixin
     * @mixes Vaadin.Grid.ActiveItemMixin
     * @mixes Vaadin.Grid.ScrollMixin
     * @mixes Vaadin.Grid.SelectionMixin
     * @mixes Vaadin.Grid.SortMixin
     * @mixes Vaadin.Grid.RowDetailsMixin
     * @mixes Vaadin.Grid.KeyboardNavigationMixin
     * @mixes Vaadin.Grid.FilterMixin
     * @mixes Vaadin.Grid.ColumnReorderingMixin
     * @mixes Vaadin.Grid.ColumnResizingMixin
     * @demo demo/index.html
     */
    class GridElement extends
      Vaadin.ThemableMixin(
      Vaadin.Grid.DataProviderMixin(
      Vaadin.Grid.ArrayDataProviderMixin(
      Vaadin.Grid.DynamicColumnsMixin(
      Vaadin.Grid.CellClickMixin(
      Vaadin.Grid.ActiveItemMixin(
      Vaadin.Grid.ScrollMixin(
      Vaadin.Grid.SelectionMixin(
      Vaadin.Grid.SortMixin(
      Vaadin.Grid.RowDetailsMixin(
      Vaadin.Grid.KeyboardNavigationMixin(
      Vaadin.Grid.FilterMixin(
      Vaadin.Grid.ColumnReorderingMixin(
      Vaadin.Grid.ColumnResizingMixin(
      Vaadin.Grid.ScrollerElement)))))))))))))) {

      static get is() {
        return 'vaadin-grid';
      }

      static get observers() {
        return [
          '_columnTreeChanged(_columnTree, _columnTree.*)',
        ]
      }

      static get properties() {
        return {

          _safari: {
            type: Boolean,
            value: /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          },

          _this: {
            type: Object,
            value: function() {
              return this;
            }
          },

          _ios: {
            type: Boolean,
            value: function() {
              return navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
            }
          }

        }
      }

      constructor() {
        super();
        this.addEventListener('animationend', this._onAnimationEnd);
      }

      _createScrollerRows(count) {
        const rows = [];
        for (var i = 0; i < count; i++) {
          const row = document.createElement('tr');
          row.setAttribute('part', 'row');
          row.setAttribute('role', 'row');
          if (this._columnTree) {
            this._updateRow(row, this._columnTree[this._columnTree.length - 1], 'body', false, true);
          }
          rows.push(row);
        }

        if (this._columnTree) {
          this._columnTree[this._columnTree.length - 1].forEach(c => c.notifyPath('_cells.*', c._cells));
        }

        Polymer.RenderStatus.beforeNextRender(this, this._resetKeyboardNavigation);
        return rows;
      }

      _getRowTarget() {
        return this.$.items;
      }

      _createCell(tagName) {
        const contentId = this._contentIndex = this._contentIndex + 1 || 0;
        const slotName = 'vaadin-grid-cell-content-' + contentId;

        const cellContent = document.createElement('vaadin-grid-cell-content');
        cellContent.setAttribute('slot' , slotName);

        const cell = document.createElement(tagName);
        cell.id = slotName.replace('-content-', '-');
        cell.setAttribute('tabindex', '-1');
        cell.setAttribute('role', tagName === 'td' ? 'gridcell' : 'columnheader gridcell');

        const slot = document.createElement('slot');
        slot.setAttribute('name', slotName);

        cell.appendChild(slot);

        cell._content = cellContent;

        return cell;
      }

      _updateRow(row, columns, section, isColumnRow, noNotify) {
        section = section || 'body';

        const cellsFragment = document.createDocumentFragment();
        const contentsFragment = document.createDocumentFragment();

        Array.from(row.children).forEach(cell => {
          cell._vacant = true;
        });
        row.innerHTML = '';
        if (row.id !== 'outersizer') {
          row.hidden = true;
        }
        columns.forEach((column, index) => {
          let cell;

          if (section === 'body') {
            // Body
            column._cells = column._cells || [];
            cell = column._cells.find(cell => cell._vacant);
            if (!cell) {
              cell = this._createCell('td');
              column._cells.push(cell);
            }
            cell.setAttribute('part', 'cell body-cell');
            row.appendChild(cell);

            if (index === columns.length - 1 && this._rowDetailsTemplate) {
              // Add details cell as last cell to body rows
              this._detailsCells = this._detailsCells || [];
              const detailsCell = this._detailsCells.find(cell => cell._vacant) || this._createCell('td');
              if (this._detailsCells.indexOf(detailsCell) === -1) {
                this._detailsCells.push(detailsCell);
              }
              if (!detailsCell._content.parentElement) {
                contentsFragment.appendChild(detailsCell._content);
              }
              this._configureDetailsCell(detailsCell);
              row.appendChild(detailsCell);
              detailsCell._vacant = false;
            }

            if (column.notifyPath && !noNotify) {
              column.notifyPath('_cells.*', column._cells);
            }

            const descriptionCell = column._headerCell || column._footerCell;
            if (descriptionCell) {
              cell.setAttribute('aria-labelledby', `${descriptionCell.id} ${cell.id}`);
            }
          } else {
            // Header & footer
            row.hidden = true;
            const tagName = section === 'header' ? 'th' : 'td';
            if (isColumnRow || column.localName === 'vaadin-grid-column-group') {
              cell = column[`_${section}Cell`] || this._createCell(tagName);
              row.appendChild(cell);
              if (cell._instance) {
                row.hidden = false;
              }
              column[`_${section}Cell`] = cell;
            } else {
              column._emptyCells = column._emptyCells || [];
              cell = column._emptyCells.find(cell => cell._vacant) || this._createCell(tagName);
              row.appendChild(cell);
              if (column._emptyCells.indexOf(cell) === -1) {
                column._emptyCells.push(cell);
              }
            }
            cell.setAttribute('part', `cell ${section}-cell`);
          }

          if (!cell._content.parentElement) {
            contentsFragment.appendChild(cell._content);
          }
          cell._vacant = false;
          cell._column = column;
        });

        // Might be empty if only cache was used
        this.appendChild(contentsFragment);

        this._frozenCellsChanged();
        this._updateLastColumn();
      }

      _updateScrollerItem(row, index) {
        super._updateScrollerItem(row, index);

        if (!this._columnTree) {
          return;
        }

        Array.from(row.children).forEach(cell => {
          if (cell._instance) {
            cell._instance.index = index;
          }
        });
        this._toggleAttribute('odd', index % 2, row);
        this._getItem(index, row);
      }

      _columnTreeChanged(columnTree, splices) {
        Array.from(this.$.items.children).forEach(row => {
          this._updateRow(row, columnTree[columnTree.length - 1]);
        });

        // TODO: DRY
        while (this.$.header.children.length < columnTree.length) {
          const headerRow = document.createElement('tr');
          headerRow.setAttribute('part', 'row');
          headerRow.setAttribute('role', 'row');
          this.$.header.appendChild(headerRow);

          const footerRow = document.createElement('tr');
          footerRow.setAttribute('part', 'row');
          footerRow.setAttribute('role', 'row');
          this.$.footer.appendChild(footerRow);
        }
        while (this.$.header.children.length > columnTree.length) {
          this.$.header.removeChild(this.$.header.firstElementChild);
          this.$.footer.removeChild(this.$.footer.firstElementChild);
        }

        Array.from(this.$.header.children).forEach((headerRow, index) => {
          this._updateRow(headerRow, columnTree[index], 'header', index === columnTree.length - 1);
        });

        Array.from(this.$.footer.children).forEach((footerRow, index) => {
          this._updateRow(footerRow, columnTree[columnTree.length - 1 - index], 'footer', index === 0);
        });

        // Sizer row
        this._updateRow(this.$.outersizer, columnTree[columnTree.length - 1]);

        this._resizeHandler();
        this._frozenCellsChanged();
        this._updateLastColumn();
        this._resetKeyboardNavigation();
      }

      _updateItem(row, item) {
        // row.style.minHeight = item ? '' : this.$.scroller._physicalAverage + 'px';
        row._item = item;
        Array.from(row.children).forEach((cell) => {
          if (cell._instance) {
            cell._instance.item = item;
            cell._instance.__expanded__ = this._isExpanded(item);
            cell._instance.expanded = this._isExpanded(item);
            cell._instance.__selected__ = this._isSelected(item);
            cell._instance.selected = this._isSelected(item);
          }
        });
        this._toggleAttribute('selected', this._isSelected(item), row);
        if (this._rowDetailsTemplate) {
          this._toggleDetailsCell(row, item);
        }
      }

      _resizeHandler() {
        this._updateDetailsCellHeights();
        super._resizeHandler();
        this._updateHeaderFooterMetrics();
      }

      _updateHeaderFooterMetrics() {
        var headerHeight = this.$.header.clientHeight + 'px';
        var footerHeight = this.$.footer.clientHeight + 'px';
        [this.$.outersizer, this.$.fixedsizer, this.$.items].forEach(function(element) {
          element.style.borderTopWidth = headerHeight;
          element.style.borderBottomWidth = footerHeight;
        });

        Polymer.RenderStatus.afterNextRender(this.$.header, () => {
          if (this._pendingScrollToIndex) {
            this.scrollToIndex(this._pendingScrollToIndex);
          }
        });
      }

      _onAnimationEnd(e) {
        if (e.animationName === 'vaadin-grid-appear') {
          this._render();
          this._updateHeaderFooterMetrics();
          e.stopPropagation();
        }
      }

      _toggleAttribute(name, bool, node) {
        if (bool) {
          node.setAttribute(name, '');
        } else {
          node.removeAttribute(name);
        }
      }

      ready() {
        super.ready();

        if (document.doctype === null) {
          console.warn(
            '<vaadin-grid> requires the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.'
          );
        }
      }

    }

    customElements.define(GridElement.is, GridElement);
    /**
     * @namespace Vaadin
     */
    window.Vaadin = window.Vaadin || {};
    Vaadin.GridElement = GridElement;
  }
</script>
